---
title: "Workflow for paper: Exploring microbial community assembly along a soil-hydrological continuum"
author: "Masumi Stadler and Paul A. del Giorgio"
date: "10/08/2020"
output:
  html_document:
    self_contained: yes
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

---

## Preparation of environment

First, we will load libraries and custom functions

```{r results = "hide"}
#----------#
# PACKAGES #
#----------#
library(phyloseq)
library(tidyverse)
library(data.table)
library(plyr)
library(ggpubr) # arrange ggplots
library(ggnewscale) # two aesthetic scales
library(plotly)
library(doMC) # parallel computing
library(vegan) #vegdist, diversity
library(ape) #pcoa
library(ade4) #is.euclid

#-----------#
# FUNCTIONS #
#-----------#
source("./Functions/custom_fun.R")
source("./Functions/SET_framework.R")
```


Second, we set-up parallel computing.
```{r}
# register number of cores for parallel computing with 'apply' family
detectCores() # 24 (private PC: 4), we do not have 24 cores. It's 12 cores, 24 threads.
registerDoMC()
getDoParWorkers() # 12 (private PC: 2)

# prepare for parallel processing (with 'parallel') for 'vegan' functions
numCores <- detectCores()
cl <- makeCluster(numCores, type = "FORK") # using forking
```

---

## Preparation of data

First we gather the microbial data from the DADA2 pipeline, and combine with the meta data for analysis. We have the ASV table (community matrix, taxa in rows, samples in columns), Taxonomy table (taxonomic assignment of each ASV), dataframe with meta-data. All will be combined in a `phyloseq` object.

```{r cars}
# do we have several files per object? -> take newest version
# ASV CSS transformed table
asv.tab <- select_newest("./Output", "201520162017_CSS_asvtab")
asv.tab <- read.csv(
  paste0("./Output/", asv.tab),
  sep = "\t",
  dec = ".",
  stringsAsFactors = F
)

# transpose back to ASV in cols, samples in rows
row.names(asv.tab) <- asv.tab$Taxa.and.Samples
asv.tab[, "Taxa.and.Samples"] <- NULL
asv.tab <- as.matrix(asv.tab)
# row orders need to match between tax.tab and asv.tab
asv.tab <- asv.tab[order(row.names(asv.tab)),]

# Taxonomy table
tax.tab <- select_newest("./Output", "201520162017_tax_table")
tax.tab <-
  as.matrix(read.csv(
    paste0("./Output/", tax.tab),
    sep = ";",
    dec = ".",
    row.names = 1,
    stringsAsFactors = F
  ))
# orders need to match between tax.tab and asv.tab
tax.tab <- tax.tab[order(row.names(tax.tab)),]

# Meta data
met.df <-
  select_newest(path = "./Output", file.pattern = "201520162017_meta_data")
met.df <-
  read.csv(
    paste0("./Output/", met.df),
    sep = ";",
    dec = ".",
    stringsAsFactors = F
  )
# correct one miscategorisation
met.df[met.df$DadaNames == "RO2111.60mD",]$sample.type.year <- "Deep"

# phyloseq needs the sample names of the meta data to be the same as the microbial data
met.df <- sample_data(met.df)

# Assign rownames to be Sample ID's
rownames(met.df) <- met.df$DadaNames

# Construct phyloseq object
pb <- phyloseq(otu_table(asv.tab, taxa_are_rows = T),
               sample_data(met.df),
               tax_table(tax.tab))
```

Next, we create a colour vector for plotting.

```{r}
# merge some sample types
met.df$sample.type.year <-
  factor(
    met.df$sample.type.year,
    levels = c(
      "Soil",
      "Sediment",
      "Soilwater",
      "Hyporheicwater",
      "Wellwater",
      "Stream",
      "Tributary",
      "HeadwaterLakes",
      "PRLake",
      "Lake",
      "IslandLake",
      "Upriver",
      "Downriver",
      "RO3",
      "RO2",
      "RO1",
      "Deep",
      "Marine"
    ),
    labels = c(
      "Soil",
      "Sediment",
      "Soilwater",
      "Soilwater",
      "Groundwater",
      "Stream",
      "Tributary",
      "Riverine \nLakes",
      "Headwater \nPonds",
      "Lake",
      "Lake",
      "Upriver",
      "Downriver",
      "Reservoirs",
      "Reservoirs",
      "Reservoirs",
      "Reservoirs",
      "Estuary"
    )
  )

sample.factors <- levels(met.df$sample.type.year)

# colour blind friendly, taken from viridis, inferno and magma palette
colvec <- c("#FCFDBFFF", # Soil
            "#FEC589FF", #Sediment
            "#F9795DFF", #Soilwater
            "#DE4968FF", #Groundwater,
            "skyblue", #Stream
  "#AD347CFF",# Tributary, 
  "palegreen", #Riverine Lakes, 
  "#7AD151FF", #Headwater Ponds,
  "#FDE725FF",# Lake, 
  "#1F9F88FF", # Upriver, 
  "#375A8CFF", #Downriver,
  "orchid", #Reservoir, 
  "#050416FF") #Estuary)

names(colvec) <- as.character(sample.factors)
```

---

## Analysis

### PCoA with DNA

Subset only DNA samples, and run PCoA with Bray-Curtis dissimilarity. We will transform/approximate the Bray-Curtis matrix to Euclidean distance with a square-root transformation (Legendre & Legendre 1998).
```{r}
# subset only DNA samples
dna <- subset_samples(pb, DnaType == "DNA")

# extract ASV matrix
pb.mat <- t(otu_mat(dna))
pb.mat <- log2(pb.mat + 1) # resolves horse-shoe effect

# PCoA with Bray-Curtis
pb.bray <- vegdist(pb.mat, method = "bray")
is.euclid(pb.bray) # FALSE
pb.bray <- sqrt(pb.bray) # make Euclidean
is.euclid(pb.bray) # TRUE

# make PCoA
pb.bray.pcoa <- ape::pcoa(pb.bray)
```

We will plot the output with a custom function (avoiding repetitive code in script). For details, refer to the source code in `custom_fun.R`.

```{r}
dna.pcoa <- plot_bray(pb.bray.pcoa, .id = "DNA", colours = colvec, output = T)
p <- dna.pcoa$plot + guides(alpha = "none") # remove legend on Nucleic Acid Type, as there is only one level
p
# save
#ggsave(paste0("./Figures/Final/PCoA_log_DNA_SampleType.tiff"), p,
#       width = 12, height = 10, unit = "cm")
#ggsave(paste0("./Figures/Final/PCoA_log_DNA_SampleType.png"),  p,
#       width = 12, height = 10, unit = "cm")
```

Run PERMANOVA to see whether habitat type (i.e. sample type) and seasons are different.

```{r}
# Test for significant difference between factors
ord.df <- dna.pcoa[["df"]]
adonis(pb.mat ~ sample.type.year + Season, data = ord.df, 
       sqrt.dist = T, method = "bray")
```

---

### PCoA with DNA and RNA

Next, we run the PCoA with DNA and RNA. The overall workflow is the same as with DNA only.

```{r}
# extract species table with species in columns
pb.mat <- t(otu_mat(pb))

# PCoA with Bray-Curtis
pb.bray <- vegdist(pb.mat, method = "bray")
is.euclid(pb.bray) # FALSE
pb.bray <- sqrt(pb.bray) # make Euclidean
is.euclid(pb.bray)

# make PCoA
pb.bray.pcoa <- ape::pcoa(pb.bray)
```

We will plot the first three axes.

```{r}
# plot with custom function
all.pcoa <- plot_bray(pb.bray.pcoa, .id = "All", colours = colvec, output = T)
pcoa.23 <-  plot_bray(pb.bray.pcoa, .id = "All", colours = colvec, output = T, axes = "2+3")

pcoa.plot <- all.pcoa$plot + theme(legend.position = "left")

p <- ggarrange(all.pcoa$plot, pcoa.23$plot, ncol = 2, common.legend = T, legend = "right",
               align = "hv", labels = "auto")
p

# save
#ggsave(paste0("./Figures/Final/PCoA_all_SampleType.tiff"), p,
#       width = 20, height = 11, unit = "cm")
#ggsave(paste0("./Figures/Final/PCoA_all_SampleType.png"),  p,
#       width = 20, height = 11, unit = "cm")
```

Test with PERMANOVA if composition is statistically different based on habitat type, season and nucleic acid type.

```{r}
# statistically test if factors are different
# extract ordination coordinates and factors
ord.df <- all.pcoa[["df"]]
# run PERMANOVA
adonis(pb.mat ~ sample.type.year + Season + DnaType, data = ord.df, 
                      sqrt.dist = T, method = "bray", parallel = cl)
```

---

#### Interactive 3D plots

Plot a 3D plot for interactive exploration.

Coloured by habitat type.
```{r}
plot.df <- all.pcoa[["df"]]

p1 <- plot_ly(plot.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.3, color = ~Season,
             size = 5, symbol = ~DnaType, symbols = c(21,22))
p1 <- p1 %>% add_markers()
p1 <- p1 %>% layout(scene = list(xaxis = 
                                 list(title = paste("PC1 [", unique(plot.df$x), "%]")),
                               yaxis = 
                                 list(title = paste("PC2 [", unique(plot.df$y), "%]")),
                               zaxis = 
                                 list(title = paste("PC3 [", unique(plot.df$z), "%]"))))
p1

#htmlwidgets::saveWidget(as_widget(p1), "PCoA_DNARNA_HabitatType_3D.html")
```

Coloured by season.

```{r}
p2 <- plot_ly(plot.df, x = ~Axis.1, y = ~Axis.2, z = ~Axis.3, color = ~sample.type.year,
             size = 5, symbol = ~DnaType, symbols = c(21,22))
p2 <- p2 %>% add_markers()
p2 <- p2 %>% layout(scene = list(xaxis = 
                                 list(title = paste("PC1 [", unique(plot.df$x), "%]")),
                               yaxis = 
                                 list(title = paste("PC2 [", unique(plot.df$y), "%]")),
                               zaxis = 
                                 list(title = paste("PC3 [", unique(plot.df$z), "%]"))))
p2

#htmlwidgets::saveWidget(as_widget(p1), "PCoA_DNARNA_Season_3D.html")
```

---

## Explore differences between a DNA sample and its corresponding RNA sample

We are analysing "how different" DNA and RNA composition of the same sample are through:

1. Distance within PCoA space
2. Pair-wise dissimilarity between DNA and RNA

We first started with the distance in PCoA space, however, to avoid influences from distortion in multivariate space, we thought to explore pair-wise dissimilarities, too.

As a result, we have two very different results from two metrics, that are supposed to extract the same information.

---

If we look at the raw data, it seems like soily samples (e.g. soil, soiwater, hyporheicwater) has a higher dissimilarity between DNA and RNA, compared to e.g. reservoir. DNA samples are marked with either `D` at the end, or no additional letter after Sample ID. RNA samples are marked with `R`.

Example: Hyporheic water
```{r}
as.matrix(pb.bray)[1:5,1:5]
```

Example: Soil and Soilwater
```{r}
as.matrix(pb.bray)[556:561,556:561]
```

Example: Reservoirs
```{r}
as.matrix(pb.bray)[458:465,458:465]
```

```{r}
as.matrix(pb.bray)[530:535,530:535]
```

---

This is reflected when we calculate the pair-wise dissimilarity. Again, this is a custom function to reduce code complexity. It does the same PCoA analysis as above, goes through matching DNA with their corresponding RNA sample and plots mean points with confidence intervals.

```{r}
dissim.dr <- dissim.dnarna(pb, save.name = "All", output = T)
```

And we can calculate the distance between DNA and their corresponding RNA within PCoA space, using their scores. Also a custom function, that calculates the distance as:

d(p1, p2) = sqrt((x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2)

Where x, y and z are the coordinates (site scores) of the first, second and third PCoA axes, respectively.

```{r}
dist.dr <- dist.dnarna(all.pcoa[["df"]], save.name = "3D", dimensions = 3, output = T)
```

Plot both results together.
```{r}
(p <-ggarrange(ggarrange(dist.dr$plot.main  + theme(axis.text.x = element_blank()), 
            dist.dr$plot.side  + theme(axis.text.x = element_blank()),
            widths = c(3,1),
            ncol = 2, nrow = 1, 
            common.legend = T,
            legend = "none",
            align = "h",
            font.label = list(size = 10)),
  ggarrange(dissim.dr$plot.main, 
            dissim.dr$plot.side,
            widths = c(3,1),
            ncol = 2, nrow = 1, 
            common.legend = T,
            legend = "none",
            align = "h",
            font.label = list(size = 10)),
  nrow = 2, heights = c(0.4, 0.5), labels = c("auto"), common.legend = T, align = "hv",
  legend.grob = get_legend(dist.dr$plot.main), legend = "right"))
```

It is peculiar that the two approaches yield opposing results. The PCoA is based on the same distance matrix that is used for the pair-wise dissimilarity analyses...

---

## Try PCA

Run PCA. We will transform the data with 1. logarithm base 2 and 2. Hellinger transformation so that the data can be used in a PCA, and hopefully remove bias of horse-shoe effect.

```{r}
pb.mat <- decostand(log2(pb.mat + 1), "hellinger")

pca<-prcomp(pb.mat,retx=T,center=T,scale.=F)
# extract scores and loadings
scores<-pca$x
loadings<-pca$rotation

#screeplot(pca)
#pca.pct<-100*round(summary(pca)$importance[2,],3)
#barplot(pca.pct)

# extract % of variance explained by each PC
pca.res <- summary(pca)
# extract the proprtion of variance explained by each PCA axis
exp<-data.frame(pca.res$importance)
exp <- exp[,1:2]

# site coordinates
pca.sites <- data.frame(PC1 = scores[,1]/pca$sdev[1], PC2 = scores[,2]/pca$sdev[2]) 

# species coordinates
pca.species <- loadings*matrix(pca$sdev,nrow=nrow(loadings),ncol=ncol(loadings),byrow=TRUE)
#pca.species <- pca.species *2 # choose extension factor
pca.species <- data.frame(PC1 = pca.species[,1], PC2 = pca.species[,2], Species = row.names(pca.species),
                          stringsAsFactors = F)
# loadings are weighted by sqrt(eigenvalues) (multiplied by sqrt(eigenvalues))

# export PCA scores and merge with meta data
ord.df<-data.frame(PC1=pca.sites$PC1,PC2=pca.sites$PC2, Samples = row.names(pca.sites),
                   stringsAsFactors = F)
ord.df <- merge(ord.df, sample_df(pb) %>% 
                  mutate(Samples = row.names(sample_df(pb))) %>%
                  dplyr::select(Samples, Year, Season, sample.type.year, DnaType), by = "Samples")

# set factors for plotting
ord.df$sample.type.year <- factor(ord.df$sample.type.year, levels = c("Soil","Sediment",
                                                                                "Soilwater","Hyporheicwater", 
                                                                                "Wellwater","Stream", "Tributary",
                                                                                "HeadwaterLakes", "PRLake", "Lake", "IslandLake",
                                                                                "Upriver", "Downriver","RO3", "RO2", "RO1","Deep",
                                                                                "Marine"),
                                        labels = c("Soil","Sediment",
                                                   "Soilwater","Soilwater", 
                                                   "Groundwater","Stream", "Tributary",
                                                   "Riverine \nLakes", "Headwater \nPonds", "Lake", "Lake",
                                                   "Upriver","Downriver",
                                                   "Reservoirs","Reservoirs", "Reservoirs","Reservoirs",
                                                   "Estuary"))
ord.df$Season <- factor(ord.df$Season, levels = c("spring", "summer", "autumn"), 
                        labels = c("Spring", "Summer","Autumn"))
ord.df$DnaType <- factor(ord.df$DnaType, levels = c("DNA", "cDNA"), labels = c("DNA", "RNA"))

# extract sample types represented in subset
colvec <- colvec[names(colvec) %in% as.character(levels(ord.df$sample.type.year))]

# get legend of plot separately
(
  bot.leg <-
    get_legend(
      ggplot() +
        theme_bw() +
        geom_point(data = ord.df, aes(x = PC1, y = PC2,
                                      fill = sample.type.year, shape = Season),
                   size = 2.5) +
        scale_fill_manual(values = colvec, name = "Sample Type") +
        theme(legend.position = "bottom") +
        scale_shape_manual(values = c(21, 23, 25)) +
        scale_alpha_manual(values = c(1, 0.5), name = "Nucleic Acid Type") +
        guides(shape = guide_legend(order = 1),
               alpha = guide_legend(order = 2), fill = "none")
    )
)

(pca.bi <- ggplot() +
    theme_bw() +
    geom_hline(yintercept =  0, colour = "grey80", size = 0.4) +
    geom_vline(xintercept = 0, colour = "grey80", size = 0.4) +
    geom_point(data = ord.df, aes(x = PC1, y = PC2,
                                  fill = sample.type.year, shape = Season, alpha = DnaType),
               size = 2.5) +
    #geom_text(data = pca.species, 
    #          aes(x = PC1, y = PC2, label = Species),
    #          size = 4) +
    #coord_fixed(ratio = .75) +
    scale_fill_manual(values = colvec, name = "Habitat Type") +
    scale_shape_manual(values = c(21,23,25)) +
    scale_alpha_manual(values = c(1, 0.5)) +
    coord_fixed(1) + # ensure aspect ratio
    labs(x = paste("PC1 [", round(exp$PC1[2] * 100,2),"%]"), 
         y = paste("PC2 [", round(exp$PC2[2] * 100,2),"%]")) +
    theme(legend.key.size = unit(1, "lines"),
          legend.text = element_text(size = 8),
          legend.title = element_text(size = 8),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          legend.position = "right", 
          legend.box = "vertical",
          legend.margin = margin()) +
    guides(fill = guide_legend(override.aes=list(shape=21, size = 1.7), order = 1),
           shape = guide_legend(order = 2, override.aes = list(size = 1.7))))
```


Do the same distance between DNA and RNA calculation for PCA.

```{r}
# correct a few wrong sample names for matching DNA and RNA
  ord.df[ord.df$Samples == "RO2R52R", "Samples"] <- "RO2.52R"
  ord.df[ord.df$Samples == "SWR34R", "Samples"] <- "SW34R"
  ord.df[ord.df$Samples == "RO2.36pD", "Samples"] <- "RO2.36D"
  ord.df[ord.df$Samples == "RO2.36pR", "Samples"] <- "RO2.36R"
  ord.df[ord.df$Samples == "RO2111.60mD", "Samples"] <- "RO2111.90mD"
  ord.df[ord.df$Samples == "RO2.30DPR", "Samples"] <- "RO2.30R" # two DNA
  ord.df[ord.df$Samples == "RO301.HypoR", "Samples"] <- "RO31.HypoR"
  ord.df[ord.df$Samples == "RO301R", "Samples"] <- "RO31R" 
  ord.df[ord.df$Samples == "RO304R", "Samples"] <- "RO34R" 
  ord.df[ord.df$Samples == "RO307R", "Samples"] <- "RO37R" 
  ord.df[ord.df$Samples == "L230R", "Samples"] <- "L330R" # L230 does not exist
  
  # remove Ds and Rs to match counterpart Sampless
  ord.df$ID[ord.df$DnaType == "DNA"] <- str_replace(ord.df$Samples[ord.df$DnaType == "DNA"], "D$", "")
  ord.df$ID[ord.df$DnaType == "RNA"] <- str_replace(ord.df$Samples[ord.df$DnaType == "RNA"], "R$", "")
  
  # export table to look at point positions in GIS
  #write.table(pb.scores, "./Output/BrayCurtis_scores_withmeta.csv", sep = ",", dec = ".", row.names = F)
  
    # calculate mean coordinates for duplicates
    sum <- ord.df %>% 
      filter(!Year == 2015) %>% 
      dplyr::group_by(ID, DnaType) %>%
      dplyr::summarise(x = mean(PC1), y = mean(PC2),
                       n = n()) %>%
      ungroup()
    
    setDT(sum)
    # melt ord.dftable
    temp <- dcast(sum, ID ~ DnaType, value.var = c("x","y"))
    # remove NAs
    temp <- na.omit(temp)
    # Calculate distance
    temp[, distance := sqrt(abs((x_DNA - x_RNA))^2 + abs((y_DNA - y_RNA))^2)]
    temp[, .(dist.pca1 = abs((x_DNA - x_RNA)),
             dist.pca2 = abs((y_DNA - y_RNA)))]
  
  # combine back with categories
  dist.dr <- temp[ord.df, c("sample.type.year",
                          "Year", "Season") := list(i.sample.type.year,
                                                     i.Year, i.Season), on = .(ID)]
  # add new column to split plot into main and side panel
  dist.dr[, panels := "main"]
  dist.dr[sample.type.year == "Tributary" |
            sample.type.year == "Lake" |
            sample.type.year == "Riverine \nLakes" |
            sample.type.year == "Sediment", panels := "side"]

  # calculate confidence interval and means of Samples type and season combinations
  dist.dr <- dist.dr[, .(mean =  mean(distance, na.rm = T),
                         conf.int = conf.int(distance)), by = .(sample.type.year, Season, panels)]
  
  
  # Plot
  # Bray Curtis
  # plot main plot
  
    main.b <-
      ggplot(dist.dr[panels == "main", ], aes(
        x = sample.type.year, y = mean, fill = Season
      )) +
      theme_cust(base_theme = "pubr") +
      geom_errorbar(aes(ymin = mean - conf.int, ymax = mean + conf.int, colour = Season),
                    position = position_dodge(0.7), width = 0) +
      geom_jitter(aes(fill = Season), shape = 21, 
                  position = position_dodge(0.7), size = 2.5) +
      scale_fill_manual(values = c("#009E73", "#F0E442", "#D55E00")) + # colour-blind friendly
      scale_colour_manual(values = c("#009E73", "#FFAA1D", "#D55E00")) +
      labs(x = "Habitat type", 
           y = paste0("Distance in \nordination space")) +
      lims(y = c(min(dist.dr$mean - dist.dr$conf.int, na.rm = T),
                 max(dist.dr$mean + dist.dr$conf.int, na.rm = T))) +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text = element_text(size = 8),
        axis.title.x = element_blank(),
        axis.title = element_text(size = 10)
      )
  
  
  # side panel
    side.b <-
      ggplot(dist.dr[panels == "side", ], aes(
        x = sample.type.year, y = mean, fill = Season
      )) +
      theme_cust(base_theme = "pubr") +
      geom_errorbar(aes(ymin = mean - conf.int, ymax = mean + conf.int, colour = Season),
                    position = position_dodge(0.7), width = 0) +
      geom_jitter(aes(fill = Season), shape = 21, 
                  position = position_dodge(0.7), size = 2.5) +
      scale_fill_manual(values = c("#009E73", "#F0E442", "#D55E00")) + # colour-blind friendly
      scale_colour_manual(values = c("#009E73", "#FFAA1D", "#D55E00")) +
      labs(x = "Habitat type", 
           y = paste0("Distance in ordination space")) +
      lims(y = c(min(dist.dr$mean - dist.dr$conf.int, na.rm = T),
                 max(dist.dr$mean + dist.dr$conf.int, na.rm = T))) +
      theme(
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text = element_text(size = 8),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks.y = element_blank()
      )
  
  # combine both plots
  p <- ggarrange(main.b, 
              side.b,
              widths = c(3,1),
              ncol = 2, nrow = 1, 
              common.legend = T,
              legend = "top",
              align = "h",
              font.label = list(size = 10))
    
  # add x axis title to be in the middle of two panels
  p <- annotate_figure(p, bottom = text_grob("Habitat Type"))
  p
```

